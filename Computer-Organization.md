## 计算机组成原理

####  学习方法

![计算机组成原理知识地图](https://github.com/test-wsl/Computer-Organization/blob/master/img/zhishiditu.jpg?raw=true)

* 基本组成
  * 运算器
  * 存储器
  * 控制器
  * 输入输出设备
* 指令和计算
  * 编译器如何编译和汇编		控制器
  * 二进制和编码                       运算器
  * CPU设计                               CPU时钟
  * 数据通路                               连接运算器和控制器
  * 指令执行						       异常和中断,SIMD
  * 存储器原理                           高速缓存,内存,SSD硬盘,机械硬盘
* 学习方法
  * 提问自己来串联知识点			程序的编译、链接、装载和执行，以及计算时需要用到的逻辑电路、、ALU，乃至 CPU 自发为你做的流水线、指令级并行和分支预测，还有对应访问到的硬盘、内存，以及加载到高速缓存中的数据
  * 写一些程序来验证知识点          性能
  * 通过计算机硬件发展的历史对照           
  * 不明白的知识点,多搜索,多看不同来源的资料,多交流

* 书籍
  * 入门 
    * 计算机是怎样跑起来的
    * 程序是怎样跑起来的
  * 深入学习
    * 计算机组成与设计：硬件 / 软件接口
    * 深入理解计算机系统   ([bilibili](https://www.bilibili.com/video/av24540152/)   [Youtube](https://www.youtube.com/playlist?list=PLmBgoRqEQCWy58EIwLSWwMPfkwLOLRM5R ))
    * 计算机组成:结构化方法
    * 计算机体系结构:量化研究方法
  * 其他
    * What Every Programmer Should Know About Memory
    * 编码:隐匿在计算机软硬件背后的语言
    * 程序员的自我修养:链接,装载和库

#### CPU主频和性能

* 性能(时间倒数就是性能)
  * 响应时间                   提升不容易
  * 吞吐率                       堆硬件来提高性能
  * 跑分软件          ([SPEC](https://www.spec.org/cpu2017/results/cpu2017.html))
* 计算机的计时单位 CPU时钟
  * 时间不准                  程序运行的时候需要等待其他因素的时间
  * 程序的执行时间是 user time + sys time
  * 程序的CPU执行时间 = CPU时钟周期 x 时钟周期时间
    * 时钟周期  指令数X 每条指令的平均时钟周期数(CPI)
    * 执行时间 = 指令数 X CPI X Clock Cycle Time
      * 时钟周期  主频
      * 平均时钟周期数CPI  一条指令的CPU Cycle
      * 指令数 需要执行多少指令
* 思考
  * 实际运行![time](https://github.com/test-wsl/Computer-Organization/blob/master/img/time_seq.png?raw=true)
    * 测试中使用了多核处理器,在处理时,分别分配了不同的CPU核心,会导致真实时间会小于user time + sys time .



#### 穿越功耗强, 提高性能

* 多放一些晶体管,提高时钟频率.让CPU变得 更快
* CPU  超大规模集成电路
  * 一个个晶体管组成,通过不断打开关闭晶体管,完成各种运算和功能
    * 增加密度
    * 提升主频  (散热)
  * 一个CPU功耗
    * 功耗 ~=1/2 x 负载电容 x 电压平方 x开关频率 x 晶体管数量
* 满足并行计算提高性能
  * 可以分解为几个可以并行计算的任务
  * 确保几个人的结果可以汇总到一起
  * 汇总阶段需要顺序来,一步一步来
* 阿姆达尔定律
  * 优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间
* 提升性能的原则性问题
  * 加速大概率事件
  * 流水线提高性能
  * 通过预测提高性能
    * 分支和冒险
    * 局部性原理
* 思考
  * 阅读
    * 《计算机组成与设计：软 / 硬件接口》（第 5 版）的 1.7 和 1.10 节
    * 《深入理解计算机系统》（第 3 版）的 1.9 节
  * 软件开发运用类似的原则性问题提升性能



#### 计算机指令

* 打孔卡编程

* CPU执行各种计算机指令的逻辑机器

  * 计算机指令集  不同CPU使用的不同
  * 平时存储在存储器中的计算机程序            存储程序型计算机

* 汇编语言

  * Linux 上可以使用 gcc 和 objdump命令把代码和机器码打印出来
  * 机器码和汇编代码是一一对应的
  * 高级语言到汇编代码再到机器码  变成CPU可执行的计算机指令的过程

* 解析指令和机器码

  * 算术类指令                加减乘除

  * 数据传输类指令         变量赋值,内存读写数据

  * 逻辑类指令                 逻辑与或非

  * 条件分支指令              if/esle

  * 无条件跳转指令          

    ![汇编代码](https://github.com/test-wsl/Computer-Organization/blob/master/img/huibiandaima.jpeg?raw=true)

* MISP汇编代码([MISP](https://www.mips.com/mipsopen/))

  * 32位整数,高6位操作码,剩下26位三种格式,分别为R,I,J

    * R   算术和逻辑操作
    * I    数据传输,条件分支,运算
    * J    跳转指令(高26位都是跳转后的地址)

    ![MSIP](https://github.com/test-wsl/Computer-Organization/blob/master/img/MISP.jpeg?raw=true)

* 思考

  * 参考资料
    * 《计算机组成与设计：软 / 硬件接口》第 5 版的 2.17 小节





#### 指令跳转

* CPU如何执行指令

  * 一条一条顺序执行指令

  * 寄存器   --->    CPU    

  * 触发器和寄存器

    * PC寄存器       下一条指令的内存地址    3F

    * 指令寄存器    当前执行的指令码    83 7d fc 00

    * 条件寄存器    存放条件和逻辑运算的结果   SF , zf, SF ,OF

    * 其他寄存器

      ![CPU指令](https://github.com/test-wsl/Computer-Organization/blob/master/img/CPU.jpg?raw=true)

  * if/while 使用goto 跳转到制定位置的方式实现跳转

* 总结

  * 高级语言可以使用 if...else ... 或者while/for循环 回归到机器码就为一个goto语句
  * 实现goto语句,需要保存下一条指令的指令地址,当前指令的PC寄存器,指令寄存器

* 思考

  * 推荐
    * 深入理解计算机系统   第三章 ,介绍了C和intelCPU的对应关系
  * 除了if...else和for/while,还有switch...case的条件跳转指令,其汇编代码和这个类似?
    * [IntelJMP指令](http://www.unixwiz.net/techtips/x86-jumps.html)



#### 函数调用:发生stack overflow

* Stack Overflow
* 函数调用
  * 程序栈
    * 压栈和出栈
    * 多层函数调用
      * 内存中使用栈的方法,后进先出的数据结构 , 压栈(压入数据),出栈(取出数据)
      * 栈底,栈顶
    * 栈指针
    ![POP_PUSH](https://github.com/test-wsl/Computer-Organization/blob/master/img/pop_push.jpeg?raw=true)
    * 栈大小会出现栈溢出
      * 无限递归会创建出栈溢出
    * 函数内联会让复用的程序在程序调用的地方完全展开
    * 只会被调用的函数,被称为叶子函数(叶子过程)
* 思考
  * 推荐
    * 《深入理解计算机系统（第三版）》的 3.7 小节《过程》


#### ELF和静态链接 : 程序无法在Linux 和 Windows下运行
* 编译,链接和装载:拆解程序执行
  * 通过编译器编译汇编成汇编代码,再通过汇编器转化为CPU可以理解的机器码,CPU可以执行这些机器码
  * .o文件为一个目标文件,通过链接器把多个文件条用各种函数链接起来形成一个可执行文件
  ![C执行过程](https://github.com/test-wsl/Computer-Organization/blob/master/img/C_zhixng.jpg?raw=true)
  * 可执行文件和目标文件的代码差不多,但是却很长,都是用同一种文件格式ELF格式,叫做 可执行和可链接文件格式
  * ELF文件中,变量名,函数名都存放在一个叫做符号表的位置里,
  ![ELF格式](https://github.com/test-wsl/Computer-Organization/blob/master/img/ELF.jpg?raw=true)
    * .text Section 代码段
    * .data Section 数据段
    * .rel.text Section 重定位表
    * .systab Section 符号表
  * 链接器扫描所有输入的目标文件,所有符号表信息收集起来,构成一个全局的符号表--->根据重定位表,把不确定的跳转地址的代码,变成符号表里的地址 --->最后执行一次合并
    * 只需要解析ELF文件,对应指令和数据加载到CPU执行
* 为什么Linux和Windows下的程序不能一起执行
  * 两个操作系统的可执行文件的格式不同,Linux下位ELF格式,Windows下为一种叫做PE的装载器.
  * 分工合作 
* 思考
  * 推荐阅读
    * 《程序员的自我修养——链接、装载和库》的 1～4 章
  * readelf读取演示的符号表,看存在哪些信息,通过objdump读取出重定位表,查看有哪些信息
    * readelf -s Link_example.o
    * objdump -r link_example.o

#### 程序装载:"640k内存真的不够用吗?"

* 通过装载器解析可执行文件,把对应的指令和数据加载到内存里面
* 满足装在其要求
  * 可执行程序装在之后占用的空间是连续的    指令顺序的一条一条的执行下去
  * 需要同时加载很多程序,不能让程序自己规定在内存中加载的位置
* 虚拟内存
  * 在内存中找到一个连续的内存空间,分配给程序,把内存地址空间地址和整个程序指令的内存地址做一个映射
  * 指令用到的地址位虚拟内存地址
  * 实际硬件里的空间 物理内存地址
  
  ![内存分段](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5.png?raw=true)
  
* 内存分段(连续的内存空间)
  * 内存碎片问题    Linux Swap内存
  * 内存交换
  * 硬盘访问速度比内存慢很多,内存交换时会占用一个很占内存空间的程序,会卡顿
  
  ![内存交换](![åå­äº¤æ¢.png](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2.png?raw=true)
  
* 内存分页
  * 把物理内存空间切成固定一段尺寸的大小,这样一个连续的内存的物理地址,二十按照一个一个页来
  * 通常linux下会设置位4kb
  * getconf PAGE_SIZE  查看内存页大小
  * 没有了不能使用的碎片,只有被释放出来的很多的页   通过交换也只是少数页,不会花费太多时间,加载程序不需要一次性把程序加载到物理内存.
  <<<<<<< HEAD
  * 触发CPU缺页错误,捕获之后加载

  ![内存分页](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5.png?raw=true)
* 通过虚拟内存,内存交换,内存分页,可以不需要考虑物理内存地址,大小和当前分配空间的解决技术

* 思考
  * 推荐阅读
    * 《程序员的自我修养——链接、装载和库》的第 1 章和第 6 章
  * JAVA中使用虚拟机的语言中,怎么装载到内存中
    * 不需要考虑物理分层,直接考虑对象本身的空间大小,物理硬件管理同意由jvm的操作系统解决



#### 动态链接

链接动静态,共享运行省内存

* 链接 实现代码复用    ---->   标准化.模块化

* 内存空间不够用

因此引入了动态链接,之前遇到的是静态链接

![C类库](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%BA%93%20C.jpg?raw=true)

动态链接会加载到内存中的共享库

* 文件
  * windows 下的DLL文件
  * linux下的.so文件
* 要求
  * 地址无关  代码是地址无关码   
  * 可以接受特定的输入,进而确定操作,给出返回的结果
  * 在不同的应用程序中,调用的动态链接库的虚拟内存地址不同,
  * 动态代码库内部的函数调用使用相对地址就可以, 指令中使用的内存地址,不是一个绝对的地址空间,而是一个相对于当前指令的偏移量

![动态连接共享库](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%AD%E7%89%A9%E7%90%86%E7%A9%BA%E9%97%B4.jpg?raw=true)

* 动态链接解决方案 PLT 和 GOT
  * -fPIC 编译成一个地址无关代码
  * 存在一张全局偏移表(GOF ,Global Offset Table )  
  * 共享库的代码的物理内存共享,但是数据部分是各个动态链接他的应用程序各加载一份

![GOT过程](https://github.com/test-wsl/Computer-Organization/blob/master/img/GOT%E8%A1%A8%E4%B8%AD%E5%86%85%E5%AE%B9.jpg?raw=true)

* 同样功能的代码生成的共享库,只需要在内存里保留一份,通过动态连接,可以节省内存空间
* 思考
  * 推荐阅读
    * 《程序员的自我修养：链接、装载和库》的第 7 章
  * 动态链接修改地址数据进行间接跳转,调用不确定的位置的代码的思路.
    * 

#### 二进制编码

程序 = 算法 + 数据结构  

现代计算机都是用0和1组成的二进制表示所有的信息   文本,字符等都是使用二进制表示

二进制使用的进制规则

* 逢二进一

二进制表示方法

> * 原码表示方法   两个0
> * 补码表示附属,会使整数加法变得很容易,不需要做任何特殊处理

字符串的表示 , 编码到数字

> 标识字字符串使用ASCII码标识
>
> 在表示的时候,和整数相比,占用更多的内存空间

字符集 , 字符编码

> 字符的集合   字符集
>
> “烫烫烫”
>
> unicode 编码记录一些文本,特别是一些遗留的老子服的文本,但是可能在unicode不存在,,unicode会统一把这些字符记录 U+FFFD这个编码
>
> 使用utf-8格式存储,就是\xef\xbf\xbd,连续两个放在一起,如果使用GB2312decode,就会变成"锟斤拷"
>
> 使用Visual Studio的调试器,默认使用MBCS字符集,0xCCCC表示"烫",,0xCC为未初始化的内存的赋值读到没有赋值的内存地址或者变量的时候,就会变为"烫烫烫"

![ASCII](https://github.com/test-wsl/Computer-Organization/blob/master/img/ASCII.png?raw=true)

![unicode](https://github.com/test-wsl/Computer-Organization/blob/master/img/unicode.jpg?raw=true)

* 思考	

  * 总结
  
* 明白字符和数值的逻辑层用二进制表示不够,需要在硬件里,数值和晶体管和电路的关系
  
* 推荐阅读
  
  * 《编码：隐匿在计算机软硬件背后的语言》
  
* 问题
  
  * 如果二进制的加法中，有数是负数的时候该怎么处理呢？我们今天讲了补码的表示形式，如果这个负数是原码表示的，又应该如何处理？如果是补码表示的呢？请你用二进制加法试着算一算，-5+4=-1，通过原码和补码是如何进行的？
  
    * 所有的加减法都可以转化为加法运算,一般ALU中只实现了假发运算器,,正负数相加的时候无法直接处理,使用反码,正数反码不变,负数符号不变,其余取反 
  
      > 原码补码







#### 理解电路

为什么会选择使用二进制

* 军队有击鼓进军 , 鸣金收兵 ,通过不同声音传递号令
* 为了提高传递范围
  * 电报.灯塔,烽火台   

电报机设备传输信息

* 传输的距离迅速增加,本质上使用电信号传播,输入信号到输出信号基本没有延时
* 传输速度很快
  * 电报线路过长,会有较大的电阻

继电器(电驿)

* 用于实现接力传输信号
* 需要原样传输信号,需要重复输入信号,利用电磁效应和磁铁可以实现
* 螺旋线圈+磁性开关,替代蜂鸣器和普通开关

创建出与(AND) 或(OR) 非(NOT)的逻辑

* 两个开关都打开,输出的开关才接通    与(AND)
* 两个开关中有一个打开,那么开关就打开    或(OR)
* 从关掉,通电有磁场之后打开换成默认通电,通电后关闭,得到一个非操作    反向器

![电报机](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%8F%8D%E5%90%91%E5%99%A8.jpg?raw=true)

总结

* 电报为一个基本的计算机原型 , 通过螺旋线圈+开关可以构成基本的逻辑电路,或者门电路,使用中继器处理实现长距离信号传输 , 通过设置不同的线路和开关, 实现不同的信号和处理方式.

推荐

* 《编码：隐匿在计算机软硬件背后的语言》的第 6～11 章

思考

* 异或电路,设计一个异或门电路



#### 加法器

###### 门电路 

* 计算机硬件层面设计最基本的单元

  * 与
  * 或
  * 非
  * 异或

  CPU是由一个一个的门电路组合而形成的

![基本门电路](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%9F%BA%E6%9C%AC%E9%97%A8%E7%94%B5%E8%B7%AF.jpg?raw=true)

###### 异或门和半加器

看到的基础门电路,输入的都是两个单独的bit ,输出的是一个单独的bit . 对2个8位的数,计算与 , 或 , 非的逻辑运算,只需要连续摆放8个开关,表示一个8位数. 这样两组开关,从左到右,上下单个的位开关之间,统一使用"与门"或者"或门"连起来,就是两个8位数的AND或者OR的运算.

异或门是一个简单的整数加法,所需要使用的基本门电路

通过与门电路计算是否进位

> 两个门电路打包,叫做半加器

![半加器](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%8D%8A%E5%8A%A0%E5%99%A8.jpg?raw=true)

###### 全加器

* 用两个半加器和一个火门,可以组成一个全加器

> 8个全加器串联起来就可以进行对应的两个8bit的假发就很容易 , 不过个位的进位可以作为0或者只使用一个半加器
>
> 最左侧的进位信号,并不是再进一位,二十表示是否溢出

![全加器](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%85%A8%E5%8A%A0%E5%99%A8.jpg?raw=true)

###### 总结延伸

* 分层思想
  * 硬件层面通过门电路,半加器,全加器一层层搭出加法器这样的组件,做逻辑计算的组件叫做ALU,打造强大的CPU,不会关注最细颗粒的门电路,只需要把门电路组成的ALU当成一个完成基础计算的黑盒子

![分层思想](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3.jpg?raw=true)

* 现代计算机的加法器
  * 使用一种叫做超前进位加法器
* 课后思考
  * Coursera 上开设的《计算机组成》课程中的 Video-306 “加法器优化”
  * 使用补码表示的有符号数,加法器是否可以实现正负数相加的运算
    * 负数用补码表示的话加法就和正数的加法没什么区别了，只是结果如果是负数的话，也是补码。发生溢出会有问题，最高位符号有可能会变，需要额外的标记位

#### 乘法器

###### 顺序乘法的实现过程

* 乘数为0或者1,实际上的乘法成为了位移和加法
* 最后的假发,可以使用加法器实现,乘法中只有1和0,所以可以做成输入和输出都为4个开关,中间一个开关,同时控制8个开关,实现二进制的乘法
* 位移只要不是直接连线,把正对着的开关接通,写着错开位置去接基于可以,如果左移1位,就错开一位接线
* 把乘数最右侧的个位乘以被乘数,然后把结果写入计算结果的开关,然后被乘数左移一位,乘数右移1位,然后乘数乘以被乘数,然后把结果加到刚才的结果,反复重复,指导不能左移和右移 , 仅需要加法器和一个可以左移和一个右移一位的电路,就可以实现乘法

> 加法+位移实现乘法展开
>
> 下一组的加法依赖上一组的加法的计算结果, 下一组的位移也要依赖上一组的唯一结果,这个算法是顺序的,每一组加法或者位移的运算都需要一定的时间

![乘法器](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E4%B9%98%E6%B3%95%E5%99%A8.jpg?raw=true)

![13x19](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E8%AE%A1%E7%AE%9713x19.jpeg?raw=true)



###### 并行加速方法

* 

###### 电路并行

* 门延迟 位数越多,越往高位走,等待前面的步骤越多,等待的时间叫做门延迟
* 一个全加器已经有了3T的延迟(进位需要经过3个门电路)
* 时钟频率
  * 相加的两个数是确定的,那么高位是狗会进位是确定的,计算机是连接的各种线路,不用让计算机模拟人脑的思考,连接线路
  * 把进位部分的电路完全展开,半加器到全加器再到加法器,都是基础的门电路组合而成,再展开之后,把原来需要较少的,有较多层前后依赖的门电路,展开成较多的,依赖更少的门电路.
  * 优化的本质是利用了电路天然的并行性,电路只要接通,输入的信号自动传播到所有接通的线路里.
  
  ![电路并行](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E7%94%B5%E8%B7%AF%E5%B9%B6%E8%A1%8C.jpeg?raw=true)

###### 总结延伸

* ALU和门电路大家出来乘法器, 通过简单的连接一下线路,变成并行执行,硬件电路的信号都是实时传输的

  > 通过精巧地设计电路，用较少的门电路和寄存器，就能够计算完成乘法这样相对复杂的运算。是用更少更简单的电路，但是需要更长的门延迟和时钟周期；还是用更复杂的电路，但是更短的门延迟和时钟周期来计算一个复杂的指令 , 
  >
  > RISC和CISC历史路线之争

* 推荐阅读

  * 《计算机组成与设计：硬件 / 软件接口》的 3.3 节

* 思考

  * 用电路实现一个乘法器,还需要计算出对应的余数
    * 



#### 浮点数和定点数（上）: 怎么用有限的Bit表示尽可能多的信息？

###### 浮点数的不确定性

* 能不能使用二进制表示所有实数,然后再二进制下计算它的加减乘除
* 32bit 不能表示所有实数

###### 定点数的表示

> 二进制表示十进制的编码方式  BCD编码
>
> 缺点
>
> * 浪费
> * 没办法同时表示很大或者很小的数字

###### 浮点数的表示

* 使用科学计数法表示数字  叫做IEEE的标准   32位标识单精度    64位标识双精度浮点数
* 组成
  * 符号位 s (第一位)
    
    * 正数和负数
    
  * 指数位 e(接下来的8位)
    * 8个比特的整数空间
    * 表示-126到127,-1是其中的第126个数
    
    ![单精度实数](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%8D%95%E7%B2%BE%E5%BA%A6%E5%AE%9E%E6%95%B0.jpg?raw=true)
    
    ![特殊数值](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E7%89%B9%E6%AE%8A.jpg?raw=true)
    
  * 有效位数 f
  
    * 1
* 总结
  * 浮点数表示的范围一下子打了很多,
  * BCD编码位一个定点数
  * 浮点数在表示,计算都是一个近似计算
  * 推荐
    * 《计算机组成与设计：硬件 / 软件接口》的 3.5.1 节
  * 思考
    * BCD的定点数,7个比特表示连续的两位十进制数,32位是狗可以表示一个更大一点的数据范围
    * 如果需要表示负数,那么BCD编码可以表示的数据范围是多大.

#### 浮点数和定点数(下) 

###### 浮点数的二进制转化

十进制表示位二进制

> 输入一个9.1的浮点数,二进制里,变为一个"符号位s+指数位e+有效位数f"的组合
>
> 1. 转化为二进制
>
>    ​	9转化为 1001,小数部分转化为二进制为 0.0001100110011 
>
>    ​	![0.1](https://github.com/test-wsl/Computer-Organization/blob/master/img/0.1%E8%A1%A8%E7%A4%BA.jpg?raw=true)
>
> 2. 拼接起来
>
>    ​	1001.000110011001
>
> 3. 小数点左移三维变为
>
>    ​	1.00100110011001 x 2^3
>
> 4. s 符号位为 0 ,有效位数为 001001100110011001 指数为3,对应的为127的偏移量 , 对应的为130 , 为 10000010
>
> 5. 表示为  010000010 0010 001100110011001...
>
>    ​		![9.1](https://github.com/test-wsl/Computer-Organization/blob/master/img/9.1.jpeg?raw=true)
>
> [动态设置](https://www.h-schmidt.net/FloatConverter/IEEE754.html)



###### 浮点数的加法和精度损失

* 如何转化为IEEE-754标准
  * 先对齐,在计算

* 在进行计算时,需要右移计算,在右移过程中,最右侧的有效位就丢掉了,发生精度丢失.
* 当两个数相差 2^24倍时,两数相加,不会发生变化

![浮点数相加](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9B%B8%E5%8A%A0.jpg?raw=true)

###### Kahan Summation 算法

> 浮点数计算的时候可以容忍一定的精度损失 , 对于一些常见的应用场景,在积少成多的过程中,会出现许多的浮点数相加,累计值会越来越大,出现大树吃小数



```java
public class KahanSummation {
  public static void main(String[] args) {
    float sum = 0.0f;
    float c = 0.0f;
    for (int i = 0; i < 20000000; i++) {
    	float x = 1.0f;
    	float y = x - c;
    	float t = sum + y;
    	c = (t-sum)-y;
    	sum = t;    	
    }
    System.out.println("sum is " + sum);   
  }	
}

```

在每次计算的过程中,都用一次减法,把当前加法计算中的损失精度记录下来,后面的循环中,把精度损失放在要加的小数上,做一次运算.

[Kahan Summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm)

###### 总结延伸

* 一般情况中,需要使用定点数或者整数类型
* 浮点数适合不需要有一个精确计算结果的情况
* 累计产生的精度损失可以使用kahan summation算法解决

* 推荐
  * 《计算机组成与设计 硬件 / 软件接口》的 3.5.2 和 3.5.3 小节
* 思考
  * 64位的浮点数加法,两束相差多少的时候,小的数在加法中会发生完全丢失?



#### 建立数据通路 指令+运算=CPU

###### 指令周期

* Fetch (取得指令)

  * 从PC寄存器找到对应的指令地址,根据指令地址从内存里把具体指令加载到指令寄存器,PC寄存器自增

* Decode(指令译码)

  * 根据寄存器里的指令,解析成要进行什么操作, 是RIJ的那种指令,要操作哪些寄存器,数据或内存地址

* Execute(执行指令)

  * 实际运行对应的R,I,J这些指令,进行逻辑操作,数据传输或者地址跳转

* 重复上面的指令

* 指令周期

  ​	![指令周期](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.jpg?raw=true)

  * 取指令阶段

    * 取指令阶段,指令存放在**存储器**,通过PC寄存器和指令寄存器由**控制器**操作
    * 指令解码由**控制器** 进行

  * 指令执行阶段

    * 无论那种指令,由**算术逻辑单元**控制,即**运算器** 处理

      ![不同组件的不同步骤](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E4%B8%8D%E5%90%8C%E7%BB%84%E4%BB%B6%E5%AE%8C%E6%88%90.jpeg?raw=true)

* 计算机中常见的周期

  * Instruction Cycle 指令周期

  * MachineCycle (机器周期或者CPU周期)  从内存中取一条指令的最短时间称为CPU周期

  * ClockCycle (时钟周期 )  CPU周期由几个时钟周期累积起来 

  * 一个指令周期包含多个CPU周期 , 而一个CPU周期包含多个时钟周期

    ![周期关系](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%91%A8%E6%9C%9F%E5%85%B3%E7%B3%BB.jpeg?raw=true)

###### 建立数据通路

* 数据通路 (处理器单元)
  * 操作单元 (组合逻辑元件 ALU) 
    * 在特定的输入下,根据组合电路逻辑,生成特定的输出
  * 存储元件 (状态元件 )
    * 通用寄存器,状态寄存器
* 建立数据通路
  * 通过数据总线,把他们链接起来,可以完成存储,处理和传输
* 控制器
  * 机械的重复"Fetch-Decode - Execute"循环中的前两个步骤,然后把最后的步骤通过控制器产生的控制信号, 交给ALU处理
  * CPU 所支持的指令, 都会在控制器里 , 被解析成不同的输出信号 , 控制器输出的控制信号,至少由2000种不同的组合

###### CPU所需的硬件电路

* ALU 无状态的根据输入计算输出结果的第一个电路

* 能够进行状态读写的电路元件(寄存器) , 使用一个电路,存储上一次的计算结果

  * 锁存器 , 以及 D 触发器

* 自动电路 , 按照固定周期,实现PC寄存器自增, 自动执行.

* 译码的电路 无论对于指令进行decode , 还是拿到地址去获取对应的数据或者指令 , 译码器的电路

  ![机器译码](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E6%8C%87%E4%BB%A4%E8%AF%91%E7%A0%81.jpeg?raw=true)

###### 总结延伸

* 需要4中基本电路 , ALU 这样的组合逻辑电路 , 用来存储数据的锁存器和D触发器 ,实现PC寄存器的计数器电路, 以及解码和寻址的译码器电路
* 推荐阅读
  * 《计算机组成与设计 硬件软件接口》的第 5 版的 4.1 到 4.4
* 思考
  * CPU一直在不停的读取下一条指令去运行 , 为什么会有满载运行和idle闲置状态呢?
    * 空闲时 会停止执行, 切断时钟信号, CPU主频瞬间降低为 0  ,功耗降低为 0 ,空闲时间很短暂 ,任务管理器中只看到CPU频率下降 , 不会看到将为 0 ,从空闲恢复时 ,会接通时钟信号 , CPU频率会上升, 所以会看到CPU的频率的起伏
    * 指的系统层面的状态 , idle空闲状态 , cpu也在执行循环指令

#### 建立数据通路（中）：指令+运算=CPU

给定输入,就能得到固定的输出 , 这样的电路称为组合逻辑电路

###### 时序逻辑电路

* 可以自动运行
  * 在接通之后可以不停的开启和关闭 , 进入一个自动运行的状态
* 存储
  * 计算结果存储在特定的电路 , 一旦输入有改变,输出也有改变
* 时序协调  
  * 各种指令的操作都有先后顺序 , 时序电路使得不同的时间按照时间顺序发送

###### 时钟信号的硬件实现

* 需要一个时钟

  * 晶体振荡器实现电路信号 , 时钟信号

    ![时钟信号](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7.jpeg?raw=true)

    ![时钟信号示意图](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7%E7%A4%BA%E6%84%8F%E5%9B%BE.jpeg?raw=true)

###### 反馈电路

* 把电路的输出信号作为输入信号 ,回到当前电路 , 这样的电路叫做反馈电路

* 一般反馈电路可以使用下面的电路表示 , 一个输出结果接回输入的反向器

  ![反馈电路](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E5%8F%8D%E9%A6%88%E7%94%B5%E8%B7%AF.jpg?raw=true)

  ![或非门](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E6%88%96%E9%9D%9E%E9%97%A8.jpg?raw=true)

  

###### 通过D触发器实现存储功能

![RS触发器](https://github.com/test-wsl/Computer-Organization/blob/master/img/RS%E8%A7%A6%E5%8F%91%E5%99%A8.jpeg?raw=true)

* 利用开关和相同的反馈电路 , 可以构造出有记忆的电路 , 可以在CPU中存储计算结果的计算结果的寄存器 , 也可作为存储器

![RS触发器真值表](https://github.com/test-wsl/Computer-Organization/blob/master/img/RS%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.jpeg?raw=true)

* 触发器

  * 接通开关 , 输出变为1 ,即使断开开关 , 输出还是1不变 , 接通S ,输出变为 0 ,输出也还是 0 ,当两个开关都断开的时候 , 最终的输出结果 , 取决于之前动作的输出结果

* 复位置位触发器 

  * 当开关都是0 的时候 , 对应的输出不是1或者 0 ,而是和Q的上一个状态一致

    ![D触发器](https://github.com/test-wsl/Computer-Organization/blob/master/img/D%E8%A7%A6%E5%8F%91%E5%99%A8.jpeg?raw=true)

  * 一个D型触发器只能控制一个比特的读写 , 但是如果多个同时并列在一起 , 可以把用同一个CLK信号控制作为所有D型触发器的开关 , 这就变成了N位的D型触发器 , 可以控制N位的读写

###### 总结延伸

* 程序需要存储 , 实现计算机的可存储和 可编程的功能
* 推荐阅读
  * 《编码：隐匿在计算机软硬件背后的语言》这本书的第 14 章和 16 章
  * 《数字逻辑应用与设计》

* CPU主频以及很高了 , 通常几GHz ,但是晶振并不能提供这样的频率 , 而是通过"外频+倍频"实现高频率的时钟信号 , 倍频和分频信号通过怎样的电路实现
  * 





#### 建立数据通路（下）：指令+运算=CPU

###### PC寄存器所需要的计数器

* PC寄存器 叫做程序计数器

  * > 有了时钟信号,可以提供定时的输入,有了D型触发器,可以在时钟信号的时间点写入数据,两个结合起来,便形成一个自动 的计数器

  * 加法器的两个输入,一个始终设置为1,另一个来自D触发器A,把加法器的输出结果写到D型触发器里,D触发器里的数据就会在固定的时钟信号为1的时候更新一次

  * 两个功能结合起来,就能固定自增1的自动计数器

    ![自增1计数器](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E8%87%AA%E5%A2%9E1%E8%AE%A1%E6%95%B0%E5%99%A8.jpg?raw=true)

  * > 每次自增之后,就可以去对应的D型触发器取值,也就是我们下一条需要运行的指令的地址,顺序的存放指令,就是为了让我们通过程序计数器定时地不断执行新指令

  * 需要在一个时钟周期里,确保执行完一条最复杂的CPU指令,也就是耗时最长的一条CPU指令,这样的设置,称为但指令周期处理器

###### 读写数据所需要的译码器

* 完成寻址的工作(译码器)

  * DRAM 并不是使用D型触发器实现,而是使用CMOS芯片实现

  * 2-1选择器

    ![21选择器](https://github.com/test-wsl/Computer-Organization/blob/master/img/21%E9%80%89%E6%8B%A9%E5%99%A8.jpeg?raw=true)

    * 两个与门,一个或们实现,通过控制反向器的输入是0还是1,觉得对应的输出信号
    * 一个反向器只能有0和1这样的状态 , 有三个不同开关,能从8个地址中选择一个,叫做3-8译码器

    ![译码器内存连接](https://github.com/test-wsl/Computer-Organization/blob/master/img/%E8%AF%91%E7%A0%81%E5%99%A8%E5%86%85%E5%AD%98%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%B7%AF.jpeg?raw=true)

  * 本质
    * 输入的多个位的信号中,根据一定的开关和电路组合,选择自己想要的信号,还可以把对应需要运行的指令码,通过译码器,找出期待的指令 , 即opcode以及对应的操作数和寄存器地址

###### 建立数据通路,构造一个简单的CPU

* D触发器 , 自动计数,以及译码器,加上ALU就可以拼装一个CPU的零件

* CPU

  ![CPU实现逻辑](https://github.com/test-wsl/Computer-Organization/blob/master/img/CPU%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91.jpeg?raw=true)

  * 自动计数器 , 随着始终主频不断自增,作为PC寄存器
  * 计数器之后,加上译码器,同时连着大量的D触发器组成的内存
  * 自动计数器自增,从译码器中,找到对应的计数器表示的内存地址,读取CPU指令
  * 读取CPU指令通过CPU时钟控制,写入到一个D触发器组成的寄存器(指令寄存器)
  * 指令寄存器后跟一个译码器,把拿到的指令解析成opcode和对应的操作数
  * 拿到opcode和操作数,对应的输出连接ALU,开始算术和逻辑运算

* 条件码寄存器,jmp指令根据条件码寄存器中的标志位,决定是否跳转以及跳转到什么地址  匹配电路层面 "译码-执行-更新寄存器"的步骤

* CPU周期,指令周期,时钟周期

  * 执行一条指令可以不在一个时钟周期
  * 在一个执行一条指令,可以拆分到多个时钟周期,而不是必须使用但指令周期处理器的设计
  * 现代优化CPU的性能,使用流水线,分支预测等技术,在一个周期中执行多个指令

###### 总结

* 自动计数器,实现PC寄存器,译码器读取对应的指令,写道指令寄存器,再通过译码器,解析成需要的指令和操作数的地址
* 时钟信号,提供了协调的指令的执行时间和先后顺序的机制 , 
* 推荐
  * 《编码：隐匿在计算机软硬件背后的语言》的第 17 章
  * 《计算机组成与设计 硬件 / 软件接口》的 4.1 到 4.4 小节
* 思考
  * CPU执行无条件跳转,不需要使用运算器及ALU,为什么?
    * 无条件跳转没有计算的逻辑,可以不经过ALU的,但是需要把控制器的PC设置为跳转后的指令地址



